---

## **description: ROS2 Humble trajectory navigation system for TurtleBot3 Burger \- incremental development rules globs: \*.py, \*.yaml, \*.launch.py, \*.md**

# **Project Identity**

You are implementing a **ROS2 Humble** trajectory navigation system for **TurtleBot3 Burger** using **Python 3**. This is a time-boxed assignment (\~17 hours core \+ extras) requiring:

* Smooth trajectory generation from discrete waypoints  
* Pure pursuit controller for differential drive tracking  
* Quantitative performance metrics and testing

# **Critical Constraints**

## **TurtleBot3 Burger Hard Limits**

* Max linear velocity: **0.22 m/s** (HARD LIMIT \- never exceed)  
* Max angular velocity: **2.84 rad/s** (HARD LIMIT \- never exceed)  
* Differential drive kinematics only (cannot move sideways)  
* These are physical constraints, not just safety clamps

## **Timing Requirements**

* Controller loop: **EXACTLY 20Hz** (50ms period) \- use ROS2 timers, not spin loops  
* Monitor loop: 10Hz  
* All nodes: `use_sim_time: True` (sync with Gazebo simulation clock)

## **QoS Configuration (CRITICAL)**

\# Trajectory topic MUST use this QoS (publisher AND all subscribers)  
trajectory\_qos \= QoSProfile(  
    reliability=QoSReliabilityPolicy.RELIABLE,  
    durability=QoSDurabilityPolicy.TRANSIENT\_LOCAL,  \# Solves late-joiner problem  
    depth=1  
)  
\# Odometry, cmd\_vel, tracking\_error: use default QoS

# **Architecture: Three Independent Nodes**

## **Node 1: trajectory\_generator.py**

* Loads waypoints from YAML parameter file (NOT hardcoded)  
* Generates smooth path using **cubic splines with arc-length parameterization**  
* Publishes `nav_msgs/Path` to `/trajectory` topic with transient\_local QoS  
* Publishes visualization markers (red waypoints, green smooth path)  
* Stays alive and republishes every 1 second (for late joiners)

## **Node 2: trajectory\_controller.py**

* Pure pursuit controller (NO additional PID layers \- keep simple)  
* Subscribes: `/trajectory` (transient\_local QoS), `/odom` (default QoS)  
* Publishes: `/cmd_vel` (default QoS)  
* Control law: `ω = 2v·sin(α)/L` where α is heading error, L is lookahead  
* Decoupled callbacks: odom stores pose, timer runs control at 20Hz deterministically

## **Node 3: trajectory\_monitor.py**

* Computes cross-track error (minimum distance to reference trajectory)  
* Publishes `/tracking_error` for live plotting  
* Logs RMS error, max error, mean error, completion time  
* Exports CSV on shutdown: `trajectory_metrics_YYYYMMDD_HHMMSS.csv`

# **Coding Standards**

## **ROS2 Python Style**

\# Node initialization pattern  
class MyNode(Node):  
    def \_\_init\_\_(self):  
        super().\_\_init\_\_('node\_name')  
          
        \# 1\. Declare parameters with defaults  
        self.declare\_parameter('param\_name', default\_value)  
          
        \# 2\. Retrieve and validate  
        self.param \= self.get\_parameter('param\_name').value  
        if self.param is None or self.param \<= 0:  
            self.get\_logger().error('Invalid param\_name')  
            raise ValueError('Parameter validation failed')  
          
        \# 3\. Create QoS profiles BEFORE publishers/subscribers  
        \# 4\. Create publishers/subscribers  
        \# 5\. Create timers  
        \# 6\. Log initialization complete

## **Error Handling \- Fail Safe, Not Silent**

\# ALWAYS check preconditions before computation  
if self.trajectory is None or len(self.trajectory.poses) \== 0:  
    self.publish\_zero\_velocity()  \# Safe fallback  
    return

\# Wrap math operations in try-except  
try:  
    omega \= (2.0 \* v \* math.sin(alpha)) / lookahead\_distance  
except ZeroDivisionError:  
    self.get\_logger().error('Lookahead distance is zero')  
    return 0.0, 0.0  \# Return safe values

## **Angle Normalization (CRITICAL)**

def normalize\_angle(self, angle):  
    """ALWAYS normalize angles to \[-π, π\] before control computation"""  
    while angle \> math.pi:  
        angle \-= 2.0 \* math.pi  
    while angle \< \-math.pi:  
        angle \+= 2.0 \* math.pi  
    return angle

\# Usage: alpha \= self.normalize\_angle(desired\_heading \- robot\_yaw)

## **Quaternion to Yaw Conversion**

\# Standard 2D yaw extraction from quaternion  
siny\_cosp \= 2.0 \* (qw \* qz \+ qx \* qy)  
cosy\_cosp \= 1.0 \- 2.0 \* (qy\*\*2 \+ qz\*\*2)  
yaw \= math.atan2(siny\_cosp, cosy\_cosp)

# **Implementation Priorities (STRICT ORDER)**

## **Phase 1: Core Functionality (Hours 1-14)**

1. **Generator node**: Load YAML, cubic spline smoothing, publish Path  
2. **Controller node skeleton**: Subscribe, store state, publish zero velocity  
3. **Controller logic**: Add pure pursuit, tune lookahead distance (start with 0.30m)  
4. **Monitor node**: Error tracking, CSV export

**Acceptance**: Robot follows straight line with RMS error \< 0.05m

## **Phase 2: Testing & Validation (Hours 15-19)**

5. Test three trajectories: straight, circle, S-curve  
6. Record metrics, generate plots, document results  
7. Error handling tests (empty waypoints, teleport robot, Ctrl+C shutdown)

**Acceptance**: 3 trajectories tested, metrics documented, videos recorded

## **Phase 3: Extensions (Hours 20+ if time permits)**

8. Trapezoidal velocity profiles  
9. Basic obstacle avoidance (simple potential field or stop-when-blocked)

**DO NOT START PHASE 3 UNTIL PHASES 1-2 ARE COMPLETE AND DOCUMENTED**

# **What You Already Have**

## **Validated Offline Simulation**

* You've already implemented and tested:  
  * Cubic spline smoothing (SciPy CubicSpline)  
  * Arc-length parameterization  
  * Pure pursuit controller  
  * Cross-track error computation  
* Achieved RMS error: 0.016m in ideal simulation  
* Expect 0.05-0.15m in Gazebo (sensor noise, timing jitter)

## **Reference Implementation (Shaurya)**

**STUDY these patterns (standard ROS2):**

* Path message construction with PoseStamped elements  
* Yaw extraction from quaternions  
* Timer-based control loop structure  
* RViz marker publishing

**DO NOT COPY these parts (your differentiators):**

* Spline implementation (use YOUR validated algorithm)  
* Time parameterization (use YOUR arc-length method)  
* Control parameters and gains  
* Waypoint arrays  
* Test metrics and validation

# **Forbidden Patterns**

## **NEVER Do These**

\# ❌ DO NOT use forms in React (if you add web interface later)  
\<form onSubmit={handleSubmit}\>  \# Forms blocked in iframe

\# ❌ DO NOT use localStorage/sessionStorage  
localStorage.setItem('trajectory', data)  \# Not supported in Claude.ai environment

\# ❌ DO NOT hardcode waypoints in Python code  
waypoints \= np.array(\[\[0,0\], \[1,0\], \[2,0\]\])  \# Use YAML parameters instead

\# ❌ DO NOT add PID on top of pure pursuit  
omega\_pid \= kp \* error \+ ki \* integral \+ kd \* derivative  \# Overcomplicates tuning

\# ❌ DO NOT spin as fast as possible  
while rclpy.ok(): rclpy.spin\_once(node)  \# Use deterministic timers instead

## **ALWAYS Do These**

\# ✅ Load waypoints from YAML parameters  
self.declare\_parameter('waypoints', \[\])  
self.waypoints \= self.get\_parameter('waypoints').value

\# ✅ Use deterministic timers for control  
self.timer \= self.create\_timer(1.0/20.0, self.control\_loop)  \# Exactly 20Hz

\# ✅ Validate parameters immediately  
if len(self.waypoints) \< 4:  \# Need at least 2 points (x,y pairs)  
    raise ValueError('Insufficient waypoints')

\# ✅ Apply velocity limits as hard constraints  
linear\_vel \= max(-0.22, min(0.22, linear\_vel))  
angular\_vel \= max(-2.84, min(2.84, angular\_vel))

# **Testing Requirements (20 points of grade)**

## **Three Canonical Trajectories**

1. **Straight line**: (0,0) → (4,0) \- validates basic tracking  
2. **Circle**: radius 1m, center (1,1) \- validates curvature handling  
3. **S-curve**: y \= 0.5*sin(0.5*x) \- validates inflection points

## **Expected Metrics (Document These)**

| Trajectory | RMS Error | Max Error | Time |
| ----- | ----- | ----- | ----- |
| Straight | \< 0.05m | \< 0.10m | \~20s |
| Circle | \< 0.15m | \< 0.25m | \~31s |
| S-curve | \< 0.20m | \< 0.30m | \~38s |

## **Deliverables Per Test**

* Gazebo \+ RViz screen recording (30-60 seconds)  
* CSV file with time, x, y, error  
* Plots: path overlay, error vs time  
* Console output showing final metrics

# **Common Pitfalls to Avoid**

1. **QoS mismatch**: Trajectory subscribers MUST match publisher (transient\_local)  
2. **Frame mismatch**: All poses use `frame_id='odom'` consistently  
3. **Index out of bounds**: Always check `len(trajectory.poses) > 0` before indexing  
4. **Angle discontinuity**: Normalize angles to \[-π, π\] BEFORE computing control  
5. **Zero lookahead**: Check `lookahead_distance > 0` before division  
6. **Startup race**: Use TimerAction delays in launch file (Gazebo: 0s, Generator: 2s, Controller/Monitor: 3s)  
7. **Shutdown without saving**: Monitor MUST call `on_shutdown()` in finally block

# **When to Ask for Clarification**

Before implementing, ask if:

* The user requests features not in the core requirements (check phase priority)  
* Parameter values seem inconsistent with TurtleBot3 specs  
* Architecture deviates from the three-node design  
* Testing approach differs from the documented test cases

# **Development Workflow**

1. **Plan before coding**: For any non-trivial change, outline the approach first  
2. **Implement incrementally**: One node at a time, test each before moving on  
3. **Validate continuously**: Use `ros2 topic echo`, `ros2 param list`, RViz visualization  
4. **Document as you go**: Update README with run instructions and parameter meanings  
5. **Test systematically**: Follow the test procedure exactly as documented

# **Success Criteria**

Your implementation succeeds when:

* ✅ All three test trajectories complete without crashes  
* ✅ Metrics meet expected thresholds (documented above)  
* ✅ Error handling tests pass (empty waypoints, teleport, shutdown)  
* ✅ Videos recorded, plots generated, CSV files exported  
* ✅ Code is clean, commented, and follows ROS2 conventions  
* ✅ You can explain every design decision and parameter value

Remember: **Core functionality \+ testing \= 90 points. Extensions \= 10 points max. Prioritize accordingly.**

